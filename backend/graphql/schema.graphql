"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime
    @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

type Query {
    "Return user accounts in the application."
    users: [User!]! @paginate(defaultCount: 10)

    "Return details about a specific user in the application"
    user(id: ID @eq): User @find

    "Validate details of a new user.  Returns true if supplied user fields would be valid."
    validateNewUser(user: ValidateNewUserInput): Boolean @returnTrue

    "Return information about the currently logged in user"
    currentUser: User @auth
    
    "Return pre-defined user roles in the application"
    role(id: ID @eq): Role @find
}

"Validate the availability of username and email via the validateNewUser query"
input ValidateNewUserInput {
    "Username.  Validation error if not unique"
    username: String
        @rules(
            apply: ["unique:users,username", "filled"]
            messages: { unique: "USERNAME_IN_USE", filled: "USERNAME_EMPTY" }
        )

    "Email. Validation error if not unique"
    email: String
        @rules(
            apply: ["unique:users,email", "email:rfc,dns", "filled"]
            messages: {
                unique: "EMAIL_IN_USE"
                email: "EMAIL_NOT_VALID"
                filled: "EMAIL_EMPTY"
            }
        )
}

"""
Input type for userCreate mutation
"""
input CreateUserInput {
    "Display name. (optional)"
    name: String
        @rules(
            apply: ["max:256"],
            message: { max: "NAME_LENGTH_EXCEEDED" }
        )

    "Username. Must be unique. (required)"
    username: String!
        @rules(
            apply: ["unique:users,username", "filled"]
            messages: { unique: "USERNAME_IN_USE", filled: "USERNAME_EMPTY" }
        )

    "Email address. Must be unique. (required)"
    email: String!
        @rules(
            apply: ["unique:users,email", "email:rfc,dns", "filled"]
            messages: {
                unique: "EMAIL_IN_USE"
                email: "EMAIL_NOT_VALID"
                filled: "EMAIL_EMPTY"
            }
        )

    "Password used to login to the application. (required)"
    password: String!
        @rules(
            apply: ["zxcvbn_min:3"]
            messages: { zxcvbn_min: "PASSWORD_NOT_COMPLEX" }
        )
        @hash
}

"""
Update user information
"""
input UpdateUserInput {
    "Display name"
    name: String
        @rules(
            apply: ["max:255"],
            message: { max: "NAME_LENGTH_EXCEEDED" }
        )
    "Username of the user. Must be unique."
    username: String
        @rules(
            apply: ["unique:users,username", "filled"]
            messages: { unique: "USERNAME_IN_USE", filled: "USERNAME_EMPTY" }
        )
    "Email address of the user. Must be unique."
    email: String
        @rules(
            apply: ["unique:users,email", "email:rfc,dns", "filled"]
            messages: {
                unique: "EMAIL_IN_USE"
                email: "EMAIL_NOT_VALID"
                filled: "EMAIL_EMPTY"
            }
        )
    "Password used to login to the application."
    password: String
        @rules(
            apply: ["zxcvbn_min:3"]
            messages: { zxcvbn_min: "PASSWORD_NOT_COMPLEX" }
        )
        @hash
}
"""
A user role for permissions
"""
type Role {
    id: ID!
    name: String!
    guard_name: String!
    created_at: DateTime
    updated_at: DateTime
}

"""
A user account.
"""
type User {
    id: ID!
    name: String
    email: String!
    username: String!
    created_at: DateTime!
    updated_at: DateTime
    roles: [Role!]!
}

type Mutation {
    "Create a new user"
    createUser(user: CreateUserInput! @spread): User! @create

    "Log in to a new session and get the user."
    login(email: String!, password: String!): User!

    "Log out from the current session, showing the user one last time."
    logout: User @guard

    "Update the user information"
    updateUser(id:ID!, user: UpdateUserInput! @spread): User! @update
}
